{"data":{"referenceCode":"function speak(line) {\n    console.log(`The ${this.type} rabbit says '${line}'`);\n}\n\nconst whiteRabbit = { type: 'white', speak };\nconst hungryRabbit = { type: 'hungry', speak };\n\nwhiteRabbit.speak(`Oh my ears and whiskers, \"how late it's getting!`);\n// The white rabbit says 'Oh my ears and whiskers, how late\n// it's getting!'\n\nhungryRabbit.speak('I could use a carrot right now.');\n// The hungry rabbit says 'I could use a carrot right now.'\n\nspeak.call(hungryRabbit, \"Burp!\");\n// The hungry rabbit says 'Burp!'\n\nfunction normalize() {\n    console.log(this.coords.map(n => n / this.length));\n}\n\nnormalize.call({ coords: [0, 2, 3], length: 5 }); // [0, 0.4, 0.6]\n\nfunction Rabbit(type) {\n    this.type = type;\n}\n\nRabbit.prototype.speak = function(line) {\n    console.log(`The ${this.type} rabbit says '${line}'`);\n};\n\nlet weirdRabbit = newRabbit(\"weird\");\n\nclass BetterRabbit {\n    constructor(type) {\n        this.type = type;\n    }\n    speak(line) {\n        console.log(`The ${this.type} rabbit says '${line}'`);\n    }\n}\n\nlet killerRabbit = new BetterRabbit(\"killer\");\n\nlet blackRabbit = new BetterRabbit(\"black\");\n\n// A ridiculous way to write classes!\nconst object = new class {\n    getWord() { return 'hello'; }\n}();\n\nconsole.log(object.getWord()); // hello\n\nletkillerRabbit = newRabbit(\"killer\");\nletblackRabbit = newRabbit(\"black\");\n\nRabbit.prototype.teeth = 'small';\nconsole.log(killerRabbit.teeth); // small\nkillerRabbit.teeth = 'long, sharp, and bloody';\nconsole.log(killerRabbit.teeth); // long, sharp, and bloody\nconsole.log(blackRabbit.teeth); // small\nconsole.log(Rabbit.prototype.teeth); // small\n\nclass Temperature {\n    constructor(celsius) { this.celsius = celsius; }\n    get fahrenheit() { returnthis.celsius * 1.8 + 32; }\n    set fahrenheit(value) { this.celsius = (value - 32) / 1.8; }\n    static fromFahrenheit(value) { return new Temperature((value - 32) / 1.8); }\n}\nconst temp = new Temperature(22);\nconsole.log(temp.fahrenheit); // 71.6\ntemp.fahrenheit = 86; // Calls fahrenheit(value)\nconsole.log(temp.celsius); // 30\n\nclass Matrix {\n    constructor(width, height, element = (x, y) => undefined) {\n        this.width = width;\n        this.height = height;\n        this.content = [];\n        for (lety = 0; y < height; y++) {\n            for (letx = 0; x < width; x++) {\n                this.content[y * width + x] = element(x, y);\n            }\n        }\n    }\n    get(x, y) {\n        return this.content[y * this.width + x];\n    }\n    set(x, y, value) {\n        this.content[y * this.width + x] = value;\n    }\n}\n\nclass MatrixIterator {\n    constructor(matrix) {\n        this.x = 0;\n        this.y = 0;\n        this.matrix = matrix;\n    }\n    next() {\n        if (this.y === this.matrix.height) return { done: true };\n        constvalue = { x: this.x, y: this.y, value: this.matrix.get(this.x, this.y) };\n        this.x++;\n        if (this.x === this.matrix.width) {\n            this.x = 0;\n            this.y++;\n        }\n        return { value, done: false };\n    }\n}\n\nconst matrix = newMatrix(2, 2, (x, y) => `value ${x},${y}`);\nfor (const { x, y, value }\n    of matrix) {\n    console.log(x, y, value);\n}\n// 0 0 value 0,0\n// 1 0 value 1,0\n// 0 1 value 0,1\n// 1 1 value 1,1\n\nclass SymmetricMatrix extends Matrix {\n    constructor(size, element = (x, y) => undefined) {\n        super(size, size, (x, y) => {\n            if (x < y) returnelement(y, x);\n            returnelement(x, y);\n        });\n    }\n    set(x, y, value) {\n        super.set(x, y, value);\n        if (x != y) { super.set(y, x, value); }\n    }\n}\nconst matrix2 = newSymmetricMatrix(5, (x, y) => `${x},${y}`);\nconsole.log(matrix.get(2, 3)); // 3,2","lang":"js"},"slides":[{"title":"A quick review of OOP","content":"<p>For some reason your slideshow doesn't let me copy paste any of the regular stuff so pretend like all your slide content is here</p>","showCodeFrom":"1"},{"title":"What methods do you need","content":"<p>See your slides for the text that should be here</p>","showCodeFrom":"1"},{"title":"Methods","content":"<p>The <strong>this</strong> keyword is <em>different</em> (weird) in JavaScript methods</p><p><br></p><p>you can think of the this keyword as an extra parameter.. bla bla bla...</p>","showCodeFrom":"1"},{"title":"The call() method","content":"<p>call() will call a method with a given this value and arguments provided individually</p><p><br></p><p>function.call(thisArg, arg1, arg2, ...)</p><p><br></p><p><strong>thisArg</strong> is optional and is the value of the this keyword passed ot the function</p><p><br></p><p><strong>arg1, arg2, ... </strong>are the arguments for the function</p>","showCodeFrom":"15"},{"title":"Arrow functions","content":"<p>code about the arrow functions can now be in the main code file instead of your presentation</p>","showCodeFrom":"18"},{"title":"Arrow functions and this","content":"<p>Content</p>","showCodeFrom":"18"},{"title":"Objects: Old vs New","content":"<p>The old way looks like this</p>","showCodeFrom":"24"},{"title":"Objects: Old vs New","content":"<p>Now objects look this way</p>","showCodeFrom":"34"},{"title":"Objects and overriding defaults","content":"<p>Space to talk about the code now</p>","showCodeFrom":"54"},{"title":"Object methods","content":"<p>Get, Set and Static</p>","showCodeFrom":"64"},{"title":"Iterators","content":"<p>First make the object class</p>","showCodeFrom":"75"},{"title":"Iterators","content":"<p>Then write an iterator class for the object with a next() function</p>","showCodeFrom":"94"},{"title":"Object Inheritence","content":"<p>One of the few ways Java is like JavaScript, inheritance (even though it is written slightly differently)</p>","showCodeFrom":"122"}]}